"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSpreadElement = exports.isOptimizedVarArgSpread = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const annotations_1 = require("../utils/annotations");
const lua_ast_1 = require("../utils/lua-ast");
const lualib_1 = require("../utils/lualib");
const scope_1 = require("../utils/scope");
const typescript_1 = require("../utils/typescript");
const multi_1 = require("./language-extensions/multi");
const diagnostics_1 = require("../utils/diagnostics");
const vararg_1 = require("./language-extensions/vararg");
function isOptimizedVarArgSpread(context, symbol, identifier) {
    if (!ts.isSpreadElement(identifier.parent)) {
        return false;
    }
    // Walk up, stopping at any scope types which could stop optimization
    const scope = scope_1.findScope(context, scope_1.ScopeType.Function | scope_1.ScopeType.Try | scope_1.ScopeType.Catch | scope_1.ScopeType.File);
    if (!scope) {
        return;
    }
    // $vararg global constant
    if (vararg_1.isGlobalVarargConstant(context, symbol, scope)) {
        return true;
    }
    // Scope must be a function scope associated with a real ts function
    if (!scope_1.isFunctionScopeWithDefinition(scope)) {
        return false;
    }
    // Identifier must be a vararg in the local function scope's parameters
    const isSpreadParameter = (p) => p.dotDotDotToken && ts.isIdentifier(p.name) && context.checker.getSymbolAtLocation(p.name) === symbol;
    if (!scope.node.parameters.some(isSpreadParameter)) {
        return false;
    }
    // De-optimize if already referenced outside of a spread, as the array may have been modified
    if (scope_1.hasReferencedSymbol(context, scope, symbol)) {
        return false;
    }
    // De-optimize if a function is being hoisted from below to above, as it may have modified the array
    if (scope_1.hasReferencedUndefinedLocalFunction(context, scope)) {
        return false;
    }
    return true;
}
exports.isOptimizedVarArgSpread = isOptimizedVarArgSpread;
// TODO: Currently it's also used as an array member
exports.transformSpreadElement = (node, context) => {
    if (ts.isIdentifier(node.expression)) {
        if (annotations_1.isVarargType(context, node.expression)) {
            context.diagnostics.push(diagnostics_1.annotationDeprecated(node, annotations_1.AnnotationKind.Vararg));
            return lua.createDotsLiteral(node);
        }
        const symbol = context.checker.getSymbolAtLocation(node.expression);
        if (symbol && isOptimizedVarArgSpread(context, symbol, node.expression)) {
            return lua.createDotsLiteral(node);
        }
    }
    const innerExpression = context.transformExpression(node.expression);
    if (annotations_1.isTupleReturnCall(context, node.expression))
        return innerExpression;
    if (ts.isCallExpression(node.expression) && multi_1.returnsMultiType(context, node.expression))
        return innerExpression;
    const type = context.checker.getTypeAtLocation(node.expression);
    if (typescript_1.isArrayType(context, type)) {
        return lua_ast_1.createUnpackCall(context, innerExpression, node);
    }
    return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Spread, node, innerExpression);
};
//# sourceMappingURL=spread.js.map