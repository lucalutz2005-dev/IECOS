"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionalChainingNotSupported = exports.annotationDeprecated = exports.annotationRemoved = exports.invalidTableSetExpression = exports.invalidTableExtensionUse = exports.invalidOperatorMappingUse = exports.invalidMultiReturnAccess = exports.invalidMultiTypeToEmptyPatternOrArrayLiteral = exports.invalidMultiTypeToNonArrayLiteral = exports.invalidMultiFunctionReturnType = exports.invalidMultiFunctionUse = exports.unsupportedVarDeclaration = exports.unresolvableRequirePath = exports.invalidAmbientIdentifierName = exports.unsupportedProperty = exports.unsupportedForTarget = exports.unsupportedRightShiftOperator = exports.unsupportedAccessorInObjectLiteral = exports.invalidMultiIterableWithoutDestructuring = exports.luaIteratorForbiddenUsage = exports.luaTableForbiddenUsage = exports.luaTableCannotBeAccessedDynamically = exports.luaTableInvalidInstanceOf = exports.luaTableCannotBeExtended = exports.luaTableMustBeAmbient = exports.invalidRangeControlVariable = exports.invalidVarargUse = exports.invalidRangeUse = exports.invalidForRangeCall = exports.annotationInvalidArgumentCount = exports.decoratorInvalidContext = exports.unsupportedOverloadAssignment = exports.unsupportedSelfFunctionConversion = exports.unsupportedNoSelfFunctionConversion = exports.forbiddenForIn = exports.unsupportedNodeKind = void 0;
const ts = require("typescript");
const CompilerOptions_1 = require("../../CompilerOptions");
const utils_1 = require("../../utils");
const createDiagnosticFactory = (category, message) => utils_1.createSerialDiagnosticFactory((node, ...args) => ({
    file: node.getSourceFile(),
    start: node.getStart(),
    length: node.getWidth(),
    messageText: typeof message === "string" ? message : message(...args),
    category,
}));
const createErrorDiagnosticFactory = (message) => createDiagnosticFactory(ts.DiagnosticCategory.Error, message);
const createWarningDiagnosticFactory = (message) => createDiagnosticFactory(ts.DiagnosticCategory.Warning, message);
exports.unsupportedNodeKind = createErrorDiagnosticFactory((kind) => `Unsupported node kind ${ts.SyntaxKind[kind]}`);
exports.forbiddenForIn = createErrorDiagnosticFactory("Iterating over arrays with 'for ... in' is not allowed.");
exports.unsupportedNoSelfFunctionConversion = createErrorDiagnosticFactory((name) => {
    const nameReference = name ? ` '${name}'` : "";
    return (`Unable to convert function with a 'this' parameter to function${nameReference} with no 'this'. ` +
        "To fix, wrap in an arrow function, or declare with 'this: void'.");
});
exports.unsupportedSelfFunctionConversion = createErrorDiagnosticFactory((name) => {
    const nameReference = name ? ` '${name}'` : "";
    return (`Unable to convert function with no 'this' parameter to function${nameReference} with 'this'. ` +
        "To fix, wrap in an arrow function, or declare with 'this: any'.");
});
exports.unsupportedOverloadAssignment = createErrorDiagnosticFactory((name) => {
    const nameReference = name ? ` to '${name}'` : "";
    return (`Unsupported assignment of function with different overloaded types for 'this'${nameReference}. ` +
        "Overloads should all have the same type for 'this'.");
});
exports.decoratorInvalidContext = createErrorDiagnosticFactory("Decorator function cannot have 'this: void'.");
exports.annotationInvalidArgumentCount = createErrorDiagnosticFactory((kind, got, expected) => `'@${kind}' expects ${expected} arguments, but got ${got}.`);
exports.invalidForRangeCall = createErrorDiagnosticFactory((message) => `Invalid @forRange call: ${message}.`);
exports.invalidRangeUse = createErrorDiagnosticFactory("$range can only be used in a for...of loop.");
exports.invalidVarargUse = createErrorDiagnosticFactory("$vararg can only be used in a spread element ('...$vararg') in global scope.");
exports.invalidRangeControlVariable = createErrorDiagnosticFactory("For loop using $range must declare a single control variable.");
exports.luaTableMustBeAmbient = createErrorDiagnosticFactory("Classes with the '@luaTable' annotation must be ambient.");
exports.luaTableCannotBeExtended = createErrorDiagnosticFactory("Cannot extend classes with the '@luaTable' annotation.");
exports.luaTableInvalidInstanceOf = createErrorDiagnosticFactory("The instanceof operator cannot be used with a '@luaTable' class.");
exports.luaTableCannotBeAccessedDynamically = createErrorDiagnosticFactory("@luaTable cannot be accessed dynamically.");
exports.luaTableForbiddenUsage = createErrorDiagnosticFactory((description) => `Invalid @luaTable usage: ${description}.`);
exports.luaIteratorForbiddenUsage = createErrorDiagnosticFactory("Unsupported use of lua iterator with '@tupleReturn' annotation in for...of statement. " +
    "You must use a destructuring statement to catch results from a lua iterator with " +
    "the '@tupleReturn' annotation.");
exports.invalidMultiIterableWithoutDestructuring = createErrorDiagnosticFactory("LuaIterable with a LuaMultiReturn return value type must be destructured.");
exports.unsupportedAccessorInObjectLiteral = createErrorDiagnosticFactory("Accessors in object literal are not supported.");
exports.unsupportedRightShiftOperator = createErrorDiagnosticFactory("Right shift operator is not supported for target Lua 5.3. Use `>>>` instead.");
const getLuaTargetName = (version) => (version === CompilerOptions_1.LuaTarget.LuaJIT ? "LuaJIT" : `Lua ${version}`);
exports.unsupportedForTarget = createErrorDiagnosticFactory((functionality, version) => `${functionality} is/are not supported for target ${getLuaTargetName(version)}.`);
exports.unsupportedProperty = createErrorDiagnosticFactory((parentName, property) => `${parentName}.${property} is unsupported.`);
exports.invalidAmbientIdentifierName = createErrorDiagnosticFactory((text) => `Invalid ambient identifier name '${text}'. Ambient identifiers must be valid lua identifiers.`);
exports.unresolvableRequirePath = createErrorDiagnosticFactory((path) => `Cannot create require path. Module '${path}' does not exist within --rootDir.`);
exports.unsupportedVarDeclaration = createErrorDiagnosticFactory("`var` declarations are not supported. Use `let` or `const` instead.");
exports.invalidMultiFunctionUse = createErrorDiagnosticFactory("The $multi function must be called in a return statement.");
exports.invalidMultiFunctionReturnType = createErrorDiagnosticFactory("The $multi function cannot be cast to a non-LuaMultiReturn type.");
exports.invalidMultiTypeToNonArrayLiteral = createErrorDiagnosticFactory("Expected an array literal.");
exports.invalidMultiTypeToEmptyPatternOrArrayLiteral = createErrorDiagnosticFactory("There must be one or more elements specified here.");
exports.invalidMultiReturnAccess = createErrorDiagnosticFactory("The LuaMultiReturn type can only be accessed via an element access expression of a numeric type.");
exports.invalidOperatorMappingUse = createErrorDiagnosticFactory("This function must always be directly called and cannot be referred to.");
exports.invalidTableExtensionUse = createErrorDiagnosticFactory("This function must be called directly and cannot be referred to.");
exports.invalidTableSetExpression = createErrorDiagnosticFactory("Table set extension can only be called as a stand-alone statement. It cannot be used as an expression in another statement.");
exports.annotationRemoved = createErrorDiagnosticFactory((kind) => `'@${kind}' has been removed and will no longer have any effect.` +
    `See https://typescripttolua.github.io/docs/advanced/compiler-annotations#${kind.toLowerCase()} for more information.`);
exports.annotationDeprecated = createWarningDiagnosticFactory((kind) => `'@${kind}' is deprecated and will be removed in a future update. Please update your code before upgrading to the next release, otherwise your project will no longer compile. ` +
    `See https://typescripttolua.github.io/docs/advanced/compiler-annotations#${kind.toLowerCase()} for more information.`);
exports.optionalChainingNotSupported = createErrorDiagnosticFactory("Optional chaining is not supported yet.");
//# sourceMappingURL=diagnostics.js.map